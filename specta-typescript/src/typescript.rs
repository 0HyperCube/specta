use std::{borrow::Cow, io, path::PathBuf};

use specta::{Language, TypeMap};
use specta_serde::is_valid_ty;

use crate::{
    detect_duplicate_type_names, export_named_datatype, BigIntExportBehavior, CommentFormatterFn,
    ExportConfig, ExportError, FormatterFn,
};

#[derive(Default, Debug)]
#[non_exhaustive]
pub struct Typescript {
    /// The file's header
    pub header: Cow<'static, str>,
    /// Should we remove the default header?
    pub remove_default_header: bool,
    /// How BigInts should be exported.
    pub bigint: BigIntExportBehavior,
    /// How comments should be rendered.
    pub comment_exporter: Option<CommentFormatterFn>,
    /// How the resulting file should be formatted.
    pub formatter: Option<FormatterFn>,
    /// The path to export the resulting bindings to.
    pub path: Option<PathBuf>,
}

impl Typescript {
    /// Configure a header for the file.
    ///
    /// This is perfect for configuring lint ignore rules or other file-level comments.
    pub fn header(mut self, header: impl Into<Cow<'static, str>>) -> Self {
        self.header = header.into();
        self
    }

    /// TODO
    pub fn remove_default_header(mut self) -> Self {
        self.remove_default_header = true;
        self
    }

    /// Configure the BigInt handling behaviour
    pub fn bigint(mut self, bigint: BigIntExportBehavior) -> Self {
        self.bigint = bigint;
        self
    }

    /// Configure a function which is responsible for styling the comments to be exported
    ///
    /// Implementations:
    ///  - [`js_doc`](crate::lang::ts::js_doc)
    ///
    /// Not calling this method will default to the [`js_doc`](crate::lang::ts::js_doc) exporter.
    /// `None` will disable comment exporting.
    /// `Some(exporter)` will enable comment exporting using the provided exporter.
    pub fn comment_style(mut self, exporter: CommentFormatterFn) -> Self {
        self.comment_exporter = Some(exporter);
        self
    }

    /// Configure a function which is responsible for formatting the result file or files
    ///
    ///
    /// Implementations:
    ///  - [`prettier`](crate::lang::ts::prettier)
    ///  - [`ESLint`](crate::lang::ts::eslint)
    pub fn formatter(mut self, formatter: FormatterFn) -> Self {
        self.formatter = Some(formatter);
        self
    }

    /// TODO
    pub fn path(mut self, path: impl Into<PathBuf>) -> Self {
        self.path = Some(path.into());
        self
    }

    // TODO: Should this take a `path` or should it use `self.path`???
    /// Run the specified formatter on the given path.
    pub fn run_format(&self, path: PathBuf) -> io::Result<()> {
        if let Some(formatter) = self.formatter {
            formatter(path)?;
        }
        Ok(())
    }
}

impl Language for Typescript {
    type Error = ExportError;

    fn export(&self, type_map: TypeMap) -> Result<String, Self::Error> {
        let mut out = self.header.to_string();
        if !self.remove_default_header {
            out += "// This file has been generated by Specta. DO NOT EDIT.\n\n";
        }

        if let Some((ty_name, l0, l1)) = detect_duplicate_type_names(&type_map).into_iter().next() {
            return Err(ExportError::DuplicateTypeName(ty_name, l0, l1));
        }

        for (_, ty) in type_map.iter() {
            is_valid_ty(&ty.inner, &type_map)?;

            let config = ExportConfig::default(); // TODO: From `Self` instead.

            out += &export_named_datatype(&config, ty, &type_map)?;
            out += "\n\n";
        }

        Ok(out)
    }
}
